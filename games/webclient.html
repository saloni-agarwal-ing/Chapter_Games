<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Web Game Client</title>
  <style>
    body { font-family: sans-serif; }
    #scoreboard { margin-top: 1em; }
  </style>
</head>
<body>
  <h1>Web Game Client</h1>
  <div>
    <strong>Server Status:</strong> <span id="server-status" style="color: #999;">Not checked</span><br>
    <strong>Connection:</strong> <span id="connection-status" style="color: #999;">Not connected</span>
  </div>
  <div>
    <label>Player Name: <input id="playerName" type="text" value="Player" /></label>
    <button id="joinBtn">Join Game</button>
  </div>
  <div id="game" style="display:none;">
    <h3>Use arrow keys or buttons to move your bucket</h3>
    <canvas id="gameCanvas" width="800" height="600" style="border: 2px solid #333; background: #87CEEB;"></canvas>
    <div>
      <button onclick="sendMove('left')">Move Left</button>
      <button onclick="sendMove('right')">Move Right</button>
    </div>
    <div id="scoreboard"></div>
  </div>
  <script>
    let ws;
    let myId;
    let canvas, ctx;
    let gameState = null;

    // Keyboard movement state
    let keysPressed = {};
    let movementInterval = null;

    // Game rendering setup
    function initCanvas() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
    }

    function renderGame() {
      if (!gameState || !ctx) {
        return;
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Calculate scale factors to fit the game world in the canvas
      const scaleX = canvas.width / gameState.worldWidth;
      const scaleY = canvas.height / gameState.worldHeight;

      // Draw drops
      ctx.fillStyle = '#4169E1'; // Royal blue for water drops
      if (gameState.drops) {
        gameState.drops.forEach((drop, idx) => {
          const x = drop.x * scaleX;
          // Invert Y coordinate: game world has Y=0 at bottom, canvas has Y=0 at top
          const y = (gameState.worldHeight - drop.y) * scaleY;
          const width = gameState.dropWidth * scaleX;
          const height = gameState.dropHeight * scaleY;

          // Draw drop as a blue circle
          ctx.beginPath();
          ctx.arc(x + width/2, y + height/2, Math.max(width, height)/2, 0, 2 * Math.PI);
          ctx.fill();
        });
      }

      // Draw buckets
      if (gameState.bucketPositions) {
        Object.entries(gameState.bucketPositions).forEach(([playerId, bucketX]) => {
          const x = bucketX * scaleX;
          // Buckets are at the bottom (y=0 in world coords, which is bottom of canvas)
          const y = (gameState.worldHeight - gameState.bucketHeight) * scaleY;
          const width = gameState.bucketWidth * scaleX;
          const height = gameState.bucketHeight * scaleY;

          // Use player color or default
          const color = gameState.playerColors && gameState.playerColors[playerId]
            ? gameState.playerColors[playerId]
            : (playerId === myId ? '#FF6B6B' : '#4ECDC4');

          // Draw bucket shape (trapezoid - wider at top, narrower at bottom)
          ctx.fillStyle = color;

          const topWidth = width;
          const bottomWidth = width * 0.7; // 70% width at bottom
          const widthDiff = (topWidth - bottomWidth) / 2;

          // Draw trapezoid body
          ctx.beginPath();
          ctx.moveTo(x + widthDiff, y + height); // Bottom left
          ctx.lineTo(x, y); // Top left
          ctx.lineTo(x + topWidth, y); // Top right
          ctx.lineTo(x + topWidth - widthDiff, y + height); // Bottom right
          ctx.closePath();
          ctx.fill();

          // Draw bucket outline
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw bucket handle (arc on top)
          ctx.beginPath();
          ctx.arc(x + topWidth/2, y - 5, topWidth * 0.3, 0, Math.PI, true);
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw player name above bucket
          const playerName = gameState.playerNames && gameState.playerNames[playerId]
            ? gameState.playerNames[playerId]
            : `Player ${playerId}`;

          ctx.fillStyle = '#000';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(playerName, x + width/2, y - 25);
        });
      }
    }

    document.getElementById('joinBtn').onclick = function() {
      // Connect directly to the Java WebSocket server (no websockify proxy)
      // The Java server is running on port 8887
      const wsUrl = window.location.protocol === 'https:' ?
        'wss://' + window.location.host :
        'ws://' + window.location.hostname + ':8887';

      console.log('Connecting directly to Java WebSocket server:', wsUrl);
      console.log('Current location:', window.location);

      updateConnectionStatus('Connecting...', 'orange');

      try {
        ws = new WebSocket(wsUrl);

        ws.onopen = function() {
          console.log('WebSocket connection opened successfully');
          updateConnectionStatus('Connected', 'green');
          const joinMessage = {type: 'join', playerName: document.getElementById('playerName').value};
          console.log('Sending join message:', joinMessage);
          ws.send(JSON.stringify(joinMessage));
          document.getElementById('joinBtn').disabled = true;
          document.getElementById('playerName').disabled = true;
        };

        ws.onmessage = function(event) {
          try {
            const msg = JSON.parse(event.data);
            if (msg.type === 'welcome') {
              myId = msg.playerId;
              console.log('âœ… Joined game as Player', myId);
              updateConnectionStatus('Joined as Player ' + myId, 'green');
              document.getElementById('game').style.display = '';
              initCanvas();
            } else if (msg.type === 'gameState') {
              gameState = msg;
              updateScoreboard(msg.scoreboard, msg.playerNames);
              renderGame();
            }
          } catch (parseError) {
            console.error('Error parsing message:', parseError, 'Raw message:', event.data);
          }
        };

        ws.onerror = function(error) {
          console.error('WebSocket error occurred:', error);
          updateConnectionStatus('Connection Error', 'red');
          alert('Connection error: Unable to connect to game server. Please check your internet connection and try again.');
        };

        ws.onclose = function(event) {
          console.log('WebSocket connection closed. Code:', event.code, 'Reason:', event.reason, 'Clean:', event.wasClean);
          updateConnectionStatus('Disconnected (Code: ' + event.code + ')', 'red');
          if (event.code === 1006) {
            alert('Connection failed: Could not connect to game server. The server may be temporarily unavailable.');
          } else if (event.code === 1011) {
            alert('Server error: The game server encountered an internal error.');
          } else if (event.code === 1000) {
            console.log('Connection closed normally');
          } else {
            alert('Disconnected from server (Code: ' + event.code + '). Refreshing page...');
          }

          // Re-enable the join button
          document.getElementById('joinBtn').disabled = false;
          document.getElementById('playerName').disabled = false;
          document.getElementById('game').style.display = 'none';
          myId = null;
          gameState = null;

          // Clean up movement tracking
          keysPressed = {};
          stopContinuousMovement();
        };

      } catch (connectionError) {
        console.error('Error creating WebSocket:', connectionError);
        updateConnectionStatus('Failed to create connection', 'red');
        alert('Failed to create WebSocket connection: ' + connectionError.message);
      }
    };

    function updateConnectionStatus(message, color) {
      const statusSpan = document.getElementById('connection-status');
      statusSpan.textContent = message;
      statusSpan.style.color = color;
    }

    function checkServerStatus() {
      const statusSpan = document.getElementById('server-status');
      statusSpan.textContent = 'Checking...';

      // Test basic HTTP connectivity first
      fetch('/')
        .then(response => {
          console.log('HTTP status:', response.status, response.statusText);
          if (response.ok) {
            statusSpan.textContent = 'HTTP OK - Testing WebSocket...';
            testWebSocketConnection();
          } else {
            statusSpan.textContent = `HTTP Error: ${response.status}`;
          }
        })
        .catch(error => {
          console.error('HTTP error:', error);
          statusSpan.textContent = `HTTP Failed: ${error.message}`;
        });
    }

    function testWebSocketConnection() {
      const statusSpan = document.getElementById('server-status');
      const wsUrl = window.location.protocol === 'https:' ?
        'wss://' + window.location.host :
        'ws://' + window.location.hostname + ':8887';

      console.log('Testing WebSocket to:', wsUrl);

      try {
        const testWs = new WebSocket(wsUrl);

        const timeout = setTimeout(() => {
          testWs.close();
          statusSpan.textContent = 'WebSocket timeout';
        }, 5000);

        testWs.onopen = function() {
          clearTimeout(timeout);
          console.log('WebSocket test: connection opened');
          statusSpan.textContent = 'WebSocket OK';
          testWs.close();
        };

        testWs.onerror = function(error) {
          clearTimeout(timeout);
          console.error('WebSocket test error:', error);
          statusSpan.textContent = 'WebSocket Error';
        };

        testWs.onclose = function(event) {
          clearTimeout(timeout);
          console.log('WebSocket test closed:', event.code, event.reason);
          if (statusSpan.textContent === 'Checking...' || statusSpan.textContent === 'HTTP OK - Testing WebSocket...') {
            statusSpan.textContent = `WebSocket Failed (${event.code})`;
          }
        };

      } catch (error) {
        console.error('WebSocket creation failed:', error);
        statusSpan.textContent = `WebSocket Creation Failed: ${error.message}`;
      }
    }

    // Check server status on page load
    window.addEventListener('load', checkServerStatus);

    function sendMove(direction) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({type: 'move', direction: direction}));
      }
    }

    // Continuous movement system for faster keyboard controls
    function startContinuousMovement() {
      if (movementInterval) return; // Already running

      movementInterval = setInterval(() => {
        if (!myId || !ws || ws.readyState !== WebSocket.OPEN) return;

        if (keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['A']) {
          sendMove('left');
        }
        if (keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['D']) {
          sendMove('right');
        }
      }, 30); // Send movement command every 30ms for smooth, fast movement
    }

    function stopContinuousMovement() {
      if (movementInterval) {
        clearInterval(movementInterval);
        movementInterval = null;
      }
    }

    // Track key press
    document.addEventListener('keydown', function(event) {
      if (!myId) return;

      const key = event.key;
      if (key === 'ArrowLeft' || key === 'ArrowRight' ||
          key === 'a' || key === 'A' || key === 'd' || key === 'D') {
        event.preventDefault(); // Prevent page scrolling

        if (!keysPressed[key]) {
          keysPressed[key] = true;
          startContinuousMovement();
        }
      }
    });

    // Track key release
    document.addEventListener('keyup', function(event) {
      const key = event.key;
      if (key === 'ArrowLeft' || key === 'ArrowRight' ||
          key === 'a' || key === 'A' || key === 'd' || key === 'D') {
        delete keysPressed[key];

        // Stop interval if no movement keys are pressed
        const hasMovementKeys = keysPressed['ArrowLeft'] || keysPressed['ArrowRight'] ||
                                keysPressed['a'] || keysPressed['A'] ||
                                keysPressed['d'] || keysPressed['D'];
        if (!hasMovementKeys) {
          stopContinuousMovement();
        }
      }
    });

    function updateScoreboard(scoreboard, playerNames) {
      let html = '<h2>Scoreboard</h2><ul>';
      for (const [id, score] of Object.entries(scoreboard)) {
        const name = playerNames && playerNames[id] ? playerNames[id] : id;
        html += `<li>${name}: ${score}</li>`;
      }
      html += '</ul>';
      document.getElementById('scoreboard').innerHTML = html;
    }
  </script>
</body>
</html>
